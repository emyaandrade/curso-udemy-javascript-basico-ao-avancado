<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Página Principal - Resumos</title>
    <link rel="stylesheet" href="style/style.css">
    <link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon">
</head>

<body>
    <div class="resumo-container">
        <header class="resumo-header">
            <h1>Resumo Curso Udemy</h1>
            <p>Disciplina: JavaScript do básico ao avançado +132 projetos reais</p>
        </header>

        <section class="resumo-section">
<!-- Resumo 1 - Tipos de dados -->
            <h2>Aula 1: O que é Tipos de Dados?</h2>
            <p>Essencialmente, o JavaScript é uma linguagem de tipagem dinâmica, o que significa que não é necessário declarar o tipo de uma variável quando ela é criada. No entanto, entender os diferentes tipos de dados é crucial para programar eficazmente e evitar erros comuns.</p>

            <h3>Tipos Primitivos</h3>
<!-- Number -->
            <p><mark>Number:</mark> Representa tanto inteiros quanto números de ponto flutuante.</p>
            <div class="bloco-codigo">
                <pre>
                    let numero = 123;  //inteiro
                    let pi = 3.14159;  //ponto flutuante
                </pre>
            </div>
<!-- Strings -->
            <p><mark>Strings:</mark> Usado para representar dados textuais. Pode ser criada usando aspas simples, duplas ou crases.</p>
            <div class="bloco-codigo">
                <pre>
                    let saudacao = "Olá, mundo!";
                    let resposta = 'Sim';
                    let texto = `O valor é ${numero}`;
                </pre>
            </div>
<!-- boolean -->
            <p><mark>Boolean:</mark> True e False. O tipo booleano só tem dois valores possíveis (verdadeiro e falso). É frequentemente usado em testes lógicos.</p>
            <div class="bloco-codigo">
                <pre>
                    let maiorIdade = true;
                    let menorIdade = false;
                </pre>
            </div>
<!-- undefined -->
            <p><mark>Undefined:</mark> Uma variável que não teve um valor atribuído a ela é do tipo undefined.</p>
            <div class="bloco-codigo">
                <pre>
                    let naoDefinido;
                    console.log(naoDefinido);  //undefined
                </pre>
            </div>
<!-- null -->
            <p><mark>Null:</mark> um tipo que tem apenas um valor, null. Ele é usado para indicar a ausência deliberada de valor.</p>
            <div class="bloco-codigo">
                <pre>let vazio = null;</pre>
            </div>
<!-- Symbol -->
            <p><mark>Symbol:</mark> é usado para criar identificadores unicos para propriedades e objetos. Cada símbolo é único.</p>
            <div class="bloco-codigo">
                <pre>
                    let simbolo1 = Symbol("id");
                    let simbolo2 = Symbol("id");
                    console.log(simbolo1 === simbolo2);   //false
                </pre>
            </div>
<!-- BigInt -->
            <p><mark>BigInt:</mark> é usado para representar números inteiros muito grandes que ultrapassam o limite seguro para o tipo <strong>Number</strong>. São escritos com um "n" no final para diferenciá-los do Number.</p>
            <div class="bloco-codigo">
                let grandeNumero = 123456789123456789123456789123456789n;
            </div>
<!-- Destaque -->
            <div class="destaque">
                <p><strong>Importante:</strong> Compreender esses tipos é fundamental para o controle eficaz do comportamento do programa e para evitar erros comuns de tipo, especialmente em uma linguagem de tipagem dinâmica como JavaScript.</p>
            </div>
        </section>

        <section class="resumo-section">
            <h2>Aula 2: O que é Var, Let e Const?</h2>
            <p>São declarações usadas para definir variáveis. Cada uma tem características e escopos diferentes que influenciam como valores são armazenados, acessados e modificados. A escolha entre eles afeta a manutenibilidade e o comportamento do código.</p>
<!-- var -->
            <h3>Var</h3>
            <ul><strong>Definição e Características:</strong>
                <li>
                    É a forma mais antiga de declarar variáveis em JavaScript. As variáveis declaradas com <strong>var</strong> têm escopo de função ou são globais se declaradas fora de qualquer função.
                </li>
                <li>
                    Sofrem hoisting, o que significa que são movidas para o topo de seu escopo funcional ou global, sendo inicializadas com <strong>undefined</strong> antes de sua declaração ser executada.
                </li>
            </ul>
            <p><strong>Exemplo:</strong></p>
            <div class="bloco-codigo">
                <pre>
                    console.log(x); //undefined
                    var x = 5;
                    console.log(x);   //5
                </pre>
            </div>
            <ul><strong>Uso:</strong>
            <li>
                Devido aos problemas com escopo e hoisting, o uso de <strong>var</strong> é frequentemente desaconselhado em favor de <strong>let</strong> e <strong>const</strong>, que oferecem controle de escopo mais previsível.
            </li>
            </ul>
<!-- let -->
            <h3>Let</h3>
            <ul><strong>Definição e Características:</strong>
                <li>
                    Permite declarar variáveis com escopo de bloco, o que significa que a variável só existe dentro do bloco <strong>{}</strong> onde foi declarada.
                </li>
                <li>
                    Não sofrem hoisting de uma forma que possam ser acessadas antes da declaração. A tentativa de usá-las antes da declaração resulta em um <strong>ReferenceError</strong>.
                </li>
            </ul>
            <p><strong>Exemplo:</strong></p>
            <div class="bloco-codigo">
                <pre>
                    if (true){
                        let y = 5;
                    }
                    console.log(y);   //ReferenceError
                </pre>
            </div>
            <ul><strong>Uso:</strong>
                <li>
                    let é preferido para declarar variáveis em blocos de código específicos, especialmente em loops e condições, onde o controle de escopo é restrito e benéfico.
                </li>
            </ul>
<!-- Const -->
            <h3>Const</h3>
            <ul><strong>Definição e Características:</strong>
                <li>
                    Assim como let, a const tem escopo de bloco.
                </li>
                <li>
                    As variáveis declaradas com <strong>const</strong> devem ser inicializadas na declaração e não podem ser reatribuídas após sua inicialização. No entando, se o valor for um objeto, suas propriedades podem ser modificadas.
                </li>
                <li>
                    Assim como let, tentar acessar uma const antes de sua declaração resultará em <strong>ReferenceError</strong>.
                </li>
            </ul>
            <p><strong>Exemplo:</strong></p>
            <div class="bloco-codigo">
                <pre>
                    const z = 10;
                    z = 5;  //TypeError: Assignment to constant variable.

                    const obj = { a: 1 };
                    obj.a = 2;  //isso é permitido
                    console.log(obj);  //{ a: 2 }
                </pre>
            </div>
            <ul><strong>Uso:</strong>
                <li>const é ideal para declarar constantes cujo valor não deve mudar e também para garantir que objetos e arrays declarados não sejam completamente reatribuídos, proporcionando um nível de proteção adicional ao seu código.</li>
            </ul>
            <div class="destaque">
                <p><strong>Conclusão:</strong> A escolha entre <strong>var</strong>, <strong>let</strong> e <strong>const</strong> depende do contexto de uso:</p>
                <ul>
                    <li>
                        Use <strong>var</strong> em situações em que precisar de compatibilidade com código JavaScript muito antigo, mas geralmente evite-a devido ao seu escopo funcional amplo e hoisting.
                    </li>
                    <li>
                        Use <strong>let</strong> quando precisar de variáveis com escopo limitado a blocos, especialmente útil em loops e condições.
                    </li>
                    <li>
                        Use <strong>const</strong> quando quiser garantir que o valor da variável não seja alterado após sua inicialização, o que é útil para manter a constância e a segurança em seu código.
                    </li>
                </ul>
            </div>
        </section>

        <section class="resumo-section">
            <h2>Aula 3: Entrada de Dados</h2>
            <p>Os exemplos da aula passada demonstram como interagir com o usuário através do terminal usando o módulo <strong>readline</strong> do <mark>Node.js</mark>, capturando entrada de dados de maneira síncrona e assíncrona. Vamos detalhar os exemplos e explicar a importância das técnicas utilizadas.</p>
            <!-- entrada básica de dados -->
             <h3>Primeiro Exemplo da aula: Entrada básica de dados</h3>
             <p>Este exemplo ilustra o processo básico de interação com o usuário por meio do terminal, fazendo uma pergunta simples e recebendo a resposta.</p>
             <ol>
                <li>
                    <strong>Importação e Configuração:</strong>
                    <ul>
                        <li><strong>Importação do módulo readline:</strong> Utilizado para ler a entrada do usuário no terminal. Isso é feito através da função <strong>require</strong>, que importa módulos disponíveis no Node.js.</li>
                        <li><strong>Criação da Interface:</strong> A interface de <strong>readline</strong> é criada com <strong>readline.createInterface</strong>, configurada para usar os streams padrão de entrada (<strong>process.stdin</strong>) e saída (<strong>process.stdout</strong>). Isso permite que o programa leia a entrada do teclado e escreva no terminal.</li>
                    </ul>
                </li>
                <li>
                    <strong>Leitura de Entrada:</strong>
                    <ul>
                        <li><strong>Método question:</strong> Utilizado para fazer uma pergunta ao usuário. Este método aceita uma string de pergunta e uma função callback, que será executada quando o usuário fornecer uma resposta.</li>
                    </ul>
                </li>
                <li>
                    <strong>Tratamento de Resposta e Encerramento:</strong>
                    <ul>
                        <li><strong>Função Callback:</strong> Recebe a resposta do usuário e a utiliza para exibir uma mensagem personalizada.</li>
                        <li><strong>Fechamento da Interface:</strong> Essencial para encerrar o programa corretamente, evitando que fique pendente indefinidamente.</li>
                    </ul>
                </li>
             </ol>
             <ul>
                <mark>Por que usar essas técnicas?</mark>
                <li><strong>Modularidade:</strong> O uso de módulos como readline facilita a organização do código e reuso de funcionalidades comuns.</li>
                <li><strong>Assincronia:</strong> O método question é assíncrono, permitindo que o programa execute outras tarefas enquanto espera pela entrada do usuário.</li>
                <li><strong>Manutenção do Estado do Programa:</strong> Fechar a interface de readline após o uso é crucial para liberar recursos e permitir que o programa termine sua execução naturalmente.</li>
             </ul>
             <!-- Entrevista assíncrona com Promises -->
              <h3>Segundo Exemplo: Entrevista Assíncrona com Promises</h3>
              <p>Este exemplo avança na complexidade, usando <strong>Promises</strong> para gerenciar múltiplas entradas de forma assíncrona.</p>
              <ol>
                <li>
                    <strong>Configuração Inicial:</strong>
                    <ul>
                        <li>Semelhante ao primeiro exemplo, inclui a importação do módulo <strong>readline</strong> e a configuração da interface.</li>
                    </ul>
                </li>
                <li>
                    <strong>Função Assíncrona com Promises:</strong>
                    <ul>
                        <li><strong>Definição de fazerPergunta:</strong> Função que encapsula <strong>rl.question</strong> em uma <strong>Promise</strong>, permitindo que seja usada com <strong>await</strong> para uma sequência de perguntas de maneira mais legível e gerenciável.</li>
                        <li><strong>Resolução de Promises:</strong> Quando o usuário responde, a Promise é resolvida com a resposta, que pode então ser manipulada de maneira síncrona no fluxo do código.</li>
                    </ul>
                </li>
                <li>
                    <strong>Coleta e Exibição de Respostas:</strong>
                    <ul>
                        <li><strong>Função coletarRespostas:</strong> Utiliza <strong>await</strong> para pausar a execução do programa enquanto espera pelas respostas, criando um fluxo de execução claro e linear, apesar da natureza assíncrona das operações.</li>
                        <li><strong>Exibição e Encerramento:</strong> As respostas são coletadas e exibidas em uma mensagem formatada, e a interface é fechada.</li>
                    </ul>
                </li>
              </ol>
              <ul>
                <mark>Por que usar essas técnicas?</mark>
                <li><strong>Melhoria na Legibilidade:</strong> O uso de <strong>async/await</strong> com <strong>Promises</strong> torna o código assíncrono mais fácil de escrever e entender, comparado ao uso de callbacks aninhados.</li>
                <li><strong>Gerenciamento Eficiente de Fluxo Assíncrono:</strong> Permite a execução de várias operações assíncronas em uma sequência definida, sem bloquear o thread principal do Node.js.</li>
                <li><strong>Flexibilidade e Robustez:</strong> A abordagem com <strong>Promises</strong> e <strong>async/await</strong> fornece um controle robusto sobre o fluxo assíncrono, facilitando o tratamento de erros e a sincronização de processos dependentes.</li>
              </ul>
              <div class="destaque">
                <p>Ambos os exemplos demonstram práticas eficazes para a interação do usuário em aplicações Node.js, utilizando o módulo readline para capturar e manipular a entrada do usuário de forma síncrona e assíncrona, destacando a flexibilidade do JavaScript para lidar com diferentes padrões de entrada.</p>
              </div>


        </section>

            
        <section class="resumo-section">
            <div class="destaque-importante">
                <p><strong>Atenção:</strong> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam auctor,
                    nisl eget ultricies tincidunt.</p>
            </div>
        </section>

        <section class="resumo-section">
            <div class="destaque-perigo">
                <p><strong>Cuidado:</strong> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam auctor,
                    nisl eget ultricies tincidunt.</p>
            </div>
        </section>

        <footer class="resumo-footer">
            <p>Resumos criados por Lorem Ipsum - © 2023 Todos os direitos reservados</p>
        </footer>


    </div>
</body>

</html>